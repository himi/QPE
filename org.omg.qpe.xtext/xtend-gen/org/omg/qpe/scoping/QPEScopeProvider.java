/**
 * generated by Xtext
 */
package org.omg.qpe.scoping;

import com.google.common.base.Objects;
import com.google.inject.Inject;
import java.util.Collection;
import java.util.HashSet;
import java.util.Set;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.resource.IResourceDescription;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.omg.qpe.model.AttributePredicate;
import org.omg.qpe.model.ClassifierPredicate;
import org.omg.qpe.model.ModelPackage;
import org.omg.qpe.model.PathExpression;
import org.omg.qpe.model.Predicate;
import org.omg.qpe.model.QPE;
import org.omg.qpe.model.Qualifier;
import org.omg.qpe.model.QueryElement;
import org.omg.qpe.model.QueryNamespace;
import org.omg.qpe.model.ReferencePredicate;
import org.omg.qpe.scoping.AbstractQPEScopeProvider;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
@SuppressWarnings("all")
public class QPEScopeProvider extends AbstractQPEScopeProvider {
  @Inject
  private IResourceDescription.Manager rdMgr;
  
  public IScope scopeForFeature(final Set<EClassifier> classifiers) {
    final HashSet<EStructuralFeature> features = new HashSet<EStructuralFeature>();
    final Consumer<EClassifier> _function = (EClassifier it) -> {
      boolean _matched = false;
      if (it instanceof EClass) {
        _matched=true;
        features.addAll(((EClass)it).getEAllAttributes());
        features.addAll(((EClass)it).getEAllReferences());
      }
    };
    classifiers.forEach(_function);
    return Scopes.scopeFor(features);
  }
  
  public IScope scopeForEClassifier(final ClassifierPredicate context, final EClassifier classifier) {
    boolean _matched = false;
    if (classifier instanceof EClass) {
      _matched=true;
      final HashSet<EClass> candidates = new HashSet<EClass>();
      candidates.add(((EClass)classifier));
      final IResourceDescription rd = this.getIResourceDescription(context);
      final Iterable<IEObjectDescription> v = rd.getExportedObjects();
      final Consumer<IEObjectDescription> _function = (IEObjectDescription it) -> {
        final EObject ec = it.getEObjectOrProxy();
        boolean _matched_1 = false;
        if (ec instanceof EClass) {
          boolean _isSuperTypeOf = ((EClass)classifier).isSuperTypeOf(((EClass)ec));
          if (_isSuperTypeOf) {
            _matched_1=true;
            candidates.add(((EClass)ec));
          }
        }
      };
      v.forEach(_function);
      return Scopes.scopeFor(candidates);
    }
    return IScope.NULLSCOPE;
  }
  
  public IScope scopeForEClassifier(final ClassifierPredicate context, final EStructuralFeature feature) {
    return this.scopeForEClassifier(context, feature.getEType());
  }
  
  public IScope scopeForEAttribute(final EClassifier ec) {
    IScope _switchResult = null;
    boolean _matched = false;
    if (ec instanceof EClass) {
      _matched=true;
      _switchResult = Scopes.scopeFor(((EClass)ec).getEAllAttributes());
    }
    if (!_matched) {
      _switchResult = IScope.NULLSCOPE;
    }
    return _switchResult;
  }
  
  public IScope scopeForEAttribute(final Qualifier q) {
    IScope _xblockexpression = null;
    {
      final EClassifier ec = q.getEType();
      IScope _xifexpression = null;
      if ((ec == null)) {
        IScope _switchResult = null;
        EObject _eContainer = q.eContainer();
        final EObject qe = _eContainer;
        boolean _matched = false;
        if (qe instanceof QueryElement) {
          _matched=true;
          _switchResult = this.scopeForEAttribute(((QueryElement)qe).getFeature().getEType());
        }
        if (!_matched) {
          _switchResult = IScope.NULLSCOPE;
        }
        _xifexpression = _switchResult;
      } else {
        return this.scopeForEAttribute(ec);
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  public IScope scopeForEReference(final EClassifier ec) {
    IScope _switchResult = null;
    boolean _matched = false;
    if (ec instanceof EClass) {
      _matched=true;
      _switchResult = Scopes.scopeFor(((EClass)ec).getEAllReferences());
    }
    if (!_matched) {
      _switchResult = IScope.NULLSCOPE;
    }
    return _switchResult;
  }
  
  public IScope scopeForEReference(final Qualifier q) {
    IScope _xblockexpression = null;
    {
      final EClassifier ec = q.getEType();
      IScope _xifexpression = null;
      if ((ec == null)) {
        IScope _switchResult = null;
        EObject _eContainer = q.eContainer();
        final EObject qe = _eContainer;
        boolean _matched = false;
        if (qe instanceof QueryElement) {
          _matched=true;
          _switchResult = this.scopeForEReference(((QueryElement)qe).getFeature().getEType());
        }
        if (!_matched) {
          _switchResult = IScope.NULLSCOPE;
        }
        _xifexpression = _switchResult;
      } else {
        return this.scopeForEReference(ec);
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  public QPE getQPE(final EObject eo) {
    for (EObject e = eo; (eo != null); e = e.eContainer()) {
      if ((e instanceof QPE)) {
        return ((QPE) e);
      }
    }
    return null;
  }
  
  public QueryNamespace getDefaultNS(final QPE qpe) {
    EList<QueryNamespace> _queryNamespaces = qpe.getQueryNamespaces();
    for (final QueryNamespace qns : _queryNamespaces) {
      {
        final String prefix = qns.getPrefix();
        if (((prefix == null) || (prefix.length() == 0))) {
          return qns;
        }
      }
    }
    return null;
  }
  
  public QueryNamespace getDefaultNS(final EObject eo) {
    final QPE qpe = this.getQPE(eo);
    if ((qpe == null)) {
      return null;
    }
    return this.getDefaultNS(qpe);
  }
  
  public IResourceDescription getIResourceDescription(final Predicate p) {
    final QueryNamespace qns = p.getQueryNamespace();
    if ((qns == null)) {
      return this.getIResourceDescription(this.getDefaultNS(p));
    } else {
      return this.getIResourceDescription(qns);
    }
  }
  
  public IResourceDescription getIResourceDescription(final QueryNamespace ns) {
    final URI u = URI.createURI(ns.getIRI());
    final Resource resource = ns.eResource();
    final Resource r = resource.getResourceSet().getResource(u, true);
    return this.rdMgr.getResourceDescription(r);
  }
  
  private final String INVALID_NOMAGIC_NSURI = "http://www.nomagic.com/magicdraw/UML/2.5.0";
  
  private final String VALID_NOMAGIC_NSURI = "http://www.nomagic.com/magicdraw/UML/2.5";
  
  public EPackage getEPackage(final QueryNamespace qns) {
    if ((qns == null)) {
      return null;
    }
    final String iri = qns.getIRI();
    boolean _equals = Objects.equal(this.INVALID_NOMAGIC_NSURI, iri);
    if (_equals) {
      throw new IllegalArgumentException((((("The use of " + this.INVALID_NOMAGIC_NSURI) + " is prohibited.  Use ") + this.VALID_NOMAGIC_NSURI) + " instead"));
    }
    final EPackage ep = EPackage.Registry.INSTANCE.getEPackage(iri);
    if ((ep != null)) {
      return ep;
    }
    boolean _equals_1 = Objects.equal(iri, this.VALID_NOMAGIC_NSURI);
    if (_equals_1) {
      EPackage.Registry.INSTANCE.getEPackage(this.INVALID_NOMAGIC_NSURI);
      return EPackage.Registry.INSTANCE.getEPackage(iri);
    }
    return null;
  }
  
  public void addAllClassifiers(final QueryNamespace qns, final Collection<EClassifier> classifiers) {
    final EPackage ep = this.getEPackage(qns);
    if ((ep == null)) {
      return;
    }
    classifiers.addAll(ep.getEClassifiers());
  }
  
  public Qualifier getQualifier(final Predicate context) {
    final EObject parent = context.eContainer();
    if ((!(parent instanceof Qualifier))) {
      return null;
    }
    return ((Qualifier) parent);
  }
  
  public IScope scopeForQueryElementFeature(final QueryElement context) {
    final HashSet<EClassifier> classifiers = new HashSet<EClassifier>();
    final QueryNamespace qns = context.getQueryNamespace();
    if ((qns == null)) {
      final QueryElement prev = context.getPrev();
      if ((prev != null)) {
        classifiers.add(prev.getEType());
      } else {
        final EObject container = context.eContainer();
        if ((container instanceof PathExpression)) {
          final PathExpression pe = ((PathExpression) container);
          boolean _isIsRelative = pe.isIsRelative();
          if (_isIsRelative) {
            this.addAllClassifiers(this.getDefaultNS(context), classifiers);
          } else {
            this.addAllClassifiers(this.getDefaultNS(context), classifiers);
          }
        }
      }
    } else {
      this.addAllClassifiers(qns, classifiers);
    }
    return this.scopeForFeature(classifiers);
  }
  
  public IScope scopeForClassifierPredicateClassifier(final ClassifierPredicate context) {
    throw new Error("Unresolved compilation problems:"
      + "\nAmbiguous feature call.\nThe methods\n\tscopeForEClassifier(ClassifierPredicate, EClassifier) in QPEScopeProvider and\n\tscopeForEClassifier(ClassifierPredicate, EStructuralFeature) in QPEScopeProvider\nboth match.");
  }
  
  @Override
  public IScope getScope(final EObject context, final EReference ref) {
    IScope _switchResult = null;
    boolean _matched = false;
    if (context instanceof QueryElement) {
      EReference _queryElement_Feature = ModelPackage.eINSTANCE.getQueryElement_Feature();
      boolean _equals = Objects.equal(ref, _queryElement_Feature);
      if (_equals) {
        _matched=true;
        _switchResult = this.scopeForQueryElementFeature(((QueryElement)context));
      }
    }
    if (!_matched) {
      if (context instanceof ClassifierPredicate) {
        EReference _classifierPredicate_Classifier = ModelPackage.eINSTANCE.getClassifierPredicate_Classifier();
        boolean _equals = Objects.equal(ref, _classifierPredicate_Classifier);
        if (_equals) {
          _matched=true;
          _switchResult = this.scopeForClassifierPredicateClassifier(((ClassifierPredicate)context));
        }
      }
    }
    if (!_matched) {
      if (context instanceof AttributePredicate) {
        _matched=true;
        final Qualifier q = this.getQualifier(((Predicate)context));
        if ((q == null)) {
          return IScope.NULLSCOPE;
        }
        boolean _matched_1 = false;
        EReference _attributePredicate_Attribute = ModelPackage.eINSTANCE.getAttributePredicate_Attribute();
        if (Objects.equal(ref, _attributePredicate_Attribute)) {
          _matched_1=true;
          return this.scopeForEAttribute(q);
        }
        if (!_matched_1) {
          EAttribute _attributePredicate_Value = ModelPackage.eINSTANCE.getAttributePredicate_Value();
          if (Objects.equal(ref, _attributePredicate_Value)) {
            _matched_1=true;
            return IScope.NULLSCOPE;
          }
        }
      }
    }
    if (!_matched) {
      if (context instanceof ReferencePredicate) {
        EReference _referencePredicate_Reference = ModelPackage.eINSTANCE.getReferencePredicate_Reference();
        boolean _equals = Objects.equal(ref, _referencePredicate_Reference);
        if (_equals) {
          _matched=true;
          final Qualifier q = this.getQualifier(((Predicate)context));
          if ((q == null)) {
            return IScope.NULLSCOPE;
          }
          return this.scopeForEReference(q);
        }
      }
    }
    if (!_matched) {
      return super.getScope(context, ref);
    }
    return _switchResult;
  }
}
