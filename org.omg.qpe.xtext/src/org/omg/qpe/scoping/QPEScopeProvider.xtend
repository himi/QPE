/*
 * generated by Xtext
 */
package org.omg.qpe.scoping

import com.google.inject.Inject
import java.util.Collection
import java.util.HashSet
import java.util.Set
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EClassifier
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EPackage
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.emf.ecore.EcorePackage
import org.eclipse.xtext.resource.IResourceDescription
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider
import org.omg.qpe.model.AttributePredicate
import org.omg.qpe.model.ClassifierPredicate
import org.omg.qpe.model.PathExpression
import org.omg.qpe.model.Predicate
import org.omg.qpe.model.QPE
import org.omg.qpe.model.Qualifier
import org.omg.qpe.model.QueryElement
import org.omg.qpe.model.QueryNamespace
import org.omg.qpe.model.ReferencePredicate
import org.omg.qpe.model.ModelPackage

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class QPEScopeProvider extends AbstractQPEScopeProvider
{
    
    @Inject
    IResourceDescription.Manager rdMgr;
	
    def IScope scopeForFeature(Set<EClassifier> classifiers) {
		val features = new HashSet<EStructuralFeature>();
		classifiers.forEach[
			switch(it) {
				EClass : {
					features.addAll(it.getEAllAttributes());
					features.addAll(it.getEAllReferences());
				}
			}
		]
		return Scopes.scopeFor(features);		
	}
	
	def IScope scopeForEClassifier(ClassifierPredicate context, EClassifier classifier) {
		switch (classifier) {
			EClass : {
				// val candidates = EcoreUtil2.getCompatibleTypesOf(classifier);
                val candidates = new HashSet<EClass>;
                candidates.add(classifier);
                val rd = getIResourceDescription(context);
				// val v = rd.getExportedObjectsByType(classifier);
				val v = rd.getExportedObjects();
				
				v.forEach[
					val ec = it.getEObjectOrProxy();
					switch (ec) {
						EClass case classifier.isSuperTypeOf(ec): candidates.add(ec)
					}
				]
				
				return Scopes.scopeFor(candidates);
			}
			default: return IScope.NULLSCOPE
		}
	}
	
	def IScope scopeForEClassifier(ClassifierPredicate context, EStructuralFeature feature) {
		scopeForEClassifier(context, feature.EType)
	}
	
	def IScope scopeForEAttribute(EClassifier ec) {
		switch (ec) {
			EClass : Scopes.scopeFor(ec.EAllAttributes)
			default : IScope.NULLSCOPE
		}
	}
	
	def IScope scopeForEAttribute(Qualifier q) {
		val ec = q.EType;
		if (ec === null) {
			switch qe : q.eContainer() {
				QueryElement : scopeForEAttribute(qe.feature.EType)
				default: IScope.NULLSCOPE 
			}
		} else {
			return scopeForEAttribute(ec);
		}
	}
	
	def IScope scopeForEReference(EClassifier ec) {
		switch (ec) {
			EClass : Scopes.scopeFor(ec.EAllReferences)
			default : IScope.NULLSCOPE
		}
	}
	
	def IScope scopeForEReference(Qualifier q) {
		val ec = q.EType;
		if (ec === null) {
			switch qe : q.eContainer() {
				QueryElement : scopeForEReference(qe.feature.EType)
				default: IScope.NULLSCOPE 
			}
		} else {
			return scopeForEReference(ec);
		}
	}
	
	def QPE getQPE(EObject eo) {
		for  (var e = eo; eo !== null; e = e.eContainer()) {
			if (e instanceof QPE) return e as QPE;
		}
		return null;
	}
	
    def QueryNamespace getDefaultNS(QPE qpe) {
        for (qns : qpe.queryNamespaces) {
            val prefix = qns.prefix;
            if ((prefix === null) || (prefix.length() === 0)) return qns;
        }
        return null;
    }

    def QueryNamespace getDefaultNS(EObject eo) {
        val qpe = getQPE(eo);
        if (qpe === null) return null;
        return getDefaultNS(qpe);
    }

    def IResourceDescription getIResourceDescription(Predicate p) {
     	val qns = p.getQueryNamespace();
     	if (qns === null) {
     		return getIResourceDescription(getDefaultNS(p));
     	} else {
     		return getIResourceDescription(qns);
     	}
    }

    def IResourceDescription getIResourceDescription(QueryNamespace ns) {
        val u = URI.createURI(ns.IRI);
        val resource = ns.eResource();
        val r = resource.resourceSet.getResource(u, true);
        return rdMgr.getResourceDescription(r);
    }
	
	val INVALID_NOMAGIC_NSURI = "http://www.nomagic.com/magicdraw/UML/2.5.0";
	val VALID_NOMAGIC_NSURI = "http://www.nomagic.com/magicdraw/UML/2.5";
	
	def EPackage getEPackage(QueryNamespace qns) {
		if (qns === null) return null;
		val iri = qns.IRI;
		if (INVALID_NOMAGIC_NSURI == iri) {
			throw new IllegalArgumentException("The use of " + INVALID_NOMAGIC_NSURI + " is prohibited.  Use " + VALID_NOMAGIC_NSURI + " instead");
		}
		val ep = EPackage.Registry.INSTANCE.getEPackage(iri);
		if (ep !== null) return ep;
		if (iri == VALID_NOMAGIC_NSURI) {
			// Try to load No Magic Ecore with "http://www.nomagic.com/magicdraw/UML/2.5.0"
            EPackage.Registry.INSTANCE.getEPackage(INVALID_NOMAGIC_NSURI);
			return EPackage.Registry.INSTANCE.getEPackage(iri);
		}
		return null;
	}
	
    def addAllClassifiers(QueryNamespace qns, Collection<EClassifier> classifiers) {
         val ep = getEPackage(qns);
         if (ep === null) return;
         classifiers.addAll(ep.EClassifiers);
     }
	
	// Qualifier's predicate context->Qualifier->(QueryElement | ReferencePredicate)
	
	def Qualifier getQualifier(Predicate context) {
		val parent = context.eContainer();
		if (!(parent instanceof Qualifier)) return null;
		return parent as Qualifier;
	}
	
    def IScope scopeForQueryElementFeature(QueryElement context) {
		val classifiers = new HashSet<EClassifier>;
		val qns = context.getQueryNamespace();
		if (qns === null) {
			val prev = context.prev;
			if (prev !== null) {
				classifiers.add(prev.EType);
			} else {
				val container = context.eContainer();
				if (container instanceof PathExpression) {
					val pe = container as PathExpression;
					if (pe.isRelative) {
						addAllClassifiers(getDefaultNS(context), classifiers);
					} else {
						addAllClassifiers(getDefaultNS(context), classifiers);
					}
				}
			}
			
		} else {
			addAllClassifiers(qns, classifiers);
		}
		
		return scopeForFeature(classifiers);
	}
	
	def IScope scopeForClassifierPredicateClassifier(ClassifierPredicate context) {
		val q = getQualifier(context);
		if (q === null) return IScope.NULLSCOPE;
		val gp = q.eContainer();
		switch (gp) {
			QueryElement: scopeForEClassifier(context, gp.feature)
			ReferencePredicate: scopeForEClassifier(context, gp.reference.EReferenceType)
            PathExpression: scopeForEClassifier(context, null)
			default: IScope.NULLSCOPE
		}
		
	}
	
	override getScope(EObject context, EReference ref) {
        switch (context) {
            QueryElement case ref == ModelPackage.eINSTANCE.getQueryElement_Feature() : scopeForQueryElementFeature(context) 
            ClassifierPredicate case ref == ModelPackage.eINSTANCE.getClassifierPredicate_Classifier() : scopeForClassifierPredicateClassifier(context) 
            AttributePredicate: {
            	val q = getQualifier(context);
				if (q === null) return IScope.NULLSCOPE;
            	switch (ref) {
            		case ModelPackage.eINSTANCE.getAttributePredicate_Attribute() : return scopeForEAttribute(q)
            		case ModelPackage.eINSTANCE.getAttributePredicate_Value() : return IScope.NULLSCOPE
            	}
            }
            ReferencePredicate case ref == ModelPackage.eINSTANCE.getReferencePredicate_Reference(): {
            	val q = getQualifier(context);
				if (q === null) return IScope.NULLSCOPE;
            	return scopeForEReference(q)
            }
            default: return super.getScope(context, ref)
        }    
    }
	
}
